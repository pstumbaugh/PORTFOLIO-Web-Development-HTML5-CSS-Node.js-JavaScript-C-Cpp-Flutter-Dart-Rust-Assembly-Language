<!-- Build webpage: http://web.engr.oregonstate.edu/~stumbaup/Portfolio/ -->
<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF=8">
    <title>Patrick Stumbaugh - Portfolio</title>
    <link rel="stylesheet" href="./portfolioStyles.css" type="text/css">
  </head>

  <body class="body">

    <!-- Top of page, name -->
    
    <div class="headerText">Patrick Stumbaugh</div>
<br><br><br><br><br><br><br><br>
    <!-- Sub intro -->
    <div class="about">
      <p>Hello world!</p>
      <p>I am a jr. software developer and website designer</p>
    </div>

    <!-- header image-->
    <div class="headerImageContainer">
      <img class="headerImage" src="./images/greysideheaderImageEdited2.jpg">
    </div>

    <br>

    <!--- test scroll up
    <div class="test2">
      <img id="myImg" src="./images/portfoliopic.jpeg" width="304" height="228">
    </div> 
 -->


    <!-- Code introduction -->
    <div class="codeBackground"> </div>

    <div class="codeContainer">
      <div id="code">
        <div id="console">
          Patrick.self<br>
          <span class="answer">&nbsp;&nbsp;&gt; "Patrick Stumbaugh"<br><br></span>
          Patrick.education<br>
          <span class="answer">
            &nbsp;&nbsp;&gt; Current:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; college: "Oregon State University"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; degree: "Computer Science"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected_graduation: Fall 2021 / Winter 2022<br>
            <br>&nbsp;&nbsp;&gt; Previous:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; college: "Gonzaga University"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; degree: "Business Administration"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concentration: "Marketing"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor: "Broadcast and Electronic Media Studies"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor: "Comprehensive Leadership"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graduated: 2010<br>
            <br></span>
          Patrick.resume<br>
          <span class="answer">&nbsp;&nbsp;&gt; "<a target="_blank" href="./Resume, Patrick Stumbaugh.pdf">resume.pdf</a>"<br><br></span>
          Patrick.email<br>
          <span class="answer">&nbsp;&nbsp;&gt; "<a target="_blank" href="mailto:stumbaugh.patrick@gmail.com">stumbaugh.patrick@gmail.com</a>"<br><br></span>
          Patrick.phone<br>
          <span class="answer">&nbsp;&nbsp;&gt; "<a href="tel:6508683189">(650) 868-3189</a>"<br><br></span>
        </div>
      </div>
    </div>



    <!-- Picture and links-->
    <div class="mainPicture">
      <img id="myImage" src="./images/portpic2crop.jpeg" alt="Pat and his dogs Harper and Waldo">
      <br>
      <a target="_blank" href="https://github.com/pstumbaugh/Portfolio">
        <img id="buttonsImageCode" src="./images/githublogo2.png" alt="Github"></a>
      &nbsp;&nbsp;&nbsp;
      <a target="_blank" href="https://www.linkedin.com/in/patrick-stumbaugh-7625662a/">
        <img id="buttonsImageCode2" src="./images/linkedinlogo2.png" alt="LinkedIn"></a>
    </div>

    <div class="drippingYellowContainer">
    <img class="drippingYellow" src="./images/rightsideDrippingYellowEditedSIDES copy.png">
  </div>

    <br><br><br><br><br><br>

    
    <!-- Work Experience Examples -->


    <table class="resumeTableContainer">
      <th class="revealClass" id="revealWorkExperience1">
      <div class="headerTextBody">Current Employment</div>
      <br>

      <table class="resumeTable">
        <thread>
          <tr>
            <th class="tableTitle">Ignite (Production) Director</th>
            <th class="tableTitle2">KATU-TV</th>
          </tr>
          <tr>
            <th> </th>
            <th> Feb. 2015 - current</th>
          </tr>
          <tr>
            <th>Lead director - 5pm newscast and Afternoon Live talk show </th>
          </tr>
          <tr>
            <th>Code show elements cohesive with Ignite software</th>
          </tr>
          <tr>
            <th>Manage creative direction and production crews on special projects</th>
          </tr>
          <tr>
            <th>Develop and integrate graphic design elements</th>
          </tr>
          <tr>
            <th>End-to-end video broadcast control room management</th>
          </tr>
        </thread>
      </table>    
    </th>


    <th class="revealClass" id="revealWorkExperience2">
      <div class="headerTextBody">Previous Employment</div>
      <br>

      <table class="resumeTable">
        <thread>
          <tr>
            <th class="tableTitle">Senior Ross OverDrive Director</th>
            <th class="tableTitle2">WVLT-TV</th>
          </tr>
          <tr>
            <th> </th>
            <th> Feb. 2012 - Feb. 2015</th>
          </tr>
          <tr>
            <th>Manage station&apos;s video production operations via Ross OverDrive</th>
          </tr>
          <tr>
            <th>Assimilate Vizrt graphics software with automation control</th>
          </tr>
          <tr>
            <th>Develop and advance new automation elements</th>
          </tr>
          <tr>
            <th>Principal nightside graphic designer</th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>

        </thread>
      </table>
    </th>
  </table>

    <br>

    <a download target="_blank" href="./Resume, Patrick Stumbaugh.pdf" id="fullResume">Full Resume</a>
 
    <br><br><br>


    <!-- Coding Examples Title-->
    <div class="codeExamplesTitleContainer">
    <h4 class="codeTextBody">Coding Examples</h4>
    </div>
    <br><br><br><br>

    <!--- Code Examples -->
    <div class="codeExamplesContainer">

    <div class="codeExamplesClassReveal" id="hikersGuideReveal">
    <!-- Portland Hiker's Guide website-->
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
&lt!DOCTYPE html>
&lthtml>

  &lthead>
    &ltmeta charset="UTF=8">
    &lttitle>Portland Hiker's Guide&lt/title>
    &ltlink rel="stylesheet" href="styles.css" type="text/css">

    &ltlink rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    &ltscript src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">&lt/script>
    &ltscript src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js">&lt/script>

  &lt/head>

  &ltbody class="body">

    &ltul class="menuBarUL">
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/index">Home&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/waterfalls">Waterfall Hikes&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/shortHikes">Short Hikes&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/dogFriendlyHikes">Dog-Friendly Hikes&lt/a>&lt/li>
      &ltli class="menuBarLiRight">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/aboutMe">About&lt/a>&lt/li>
    &lt/ul>

    &ltdiv class="headerHOMEbackground">
      &ltdiv class="headerHOMEcontent">
        &ltbr>
        &lth1 style="font-size:50px">PORTLAND HIKER'S GUIDE&lt/h1>
        &ltspan class="headerHOMEcontentSub">Your guide to &ltbr> hiking in the NorthWest &lt/span>
        &ltbr>&ltbr>
        &ltspan class="headerHOMEcontentSub2">Get out there and explore! &lt/span>
      &lt/div>
    &lt/div>

    &ltbr>

    &lttable class="homeButtons">
      &ltthread>
        &lttr>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/waterfalls">
              &ltimg class="buttonsImage" src="./images/home_waterfalls.jpg" alt="Waterfall hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/shortHikes">
              &ltimg class="buttonsImage" src="./images/home_shorthikes.jpg" alt="Short hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/dogFriendlyHikes">
              &ltimg class="buttonsImage" src="./images/home_dogfriendly.jpg" alt="Dog-friendly hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/aboutMe">
              &ltimg class="buttonsImage" src="./images/home_aboutme.jpg" alt="About me">
            &lt/a>
          &lt/th>
        &lt/tr>

        &lttr>
          &ltth class="homeButtonsText">
            &lth4>
              Waterfalls
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              Short Hikes
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              Dog-friendly
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              About Me
            &lt/h4>
            &ltbr>
          &lt/th>

        &lt/tr>

      &lt/thread>
    &lt/table>

    &ltbr>

    &lttable class="carouselTable">
      &ltthread>
        &lttr>
          &ltth>
            &lt!--- adapted from https://www.w3schools.com/bootstrap/bootstrap_carousel.asp --->
            &ltdiv class="slideshow-container">
              &ltdiv id="myCarousel" class="carousel slide" data-ride="carousel">
                &lt!-- Indicators -->
                &ltol class="carousel-indicators">
                  &ltli data-target="#myCarousel" data-slide-to="0" class="active">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="1">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="2">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="3">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="4">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="5">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="6">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="7">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="8">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="9">&lt/li>
                &lt/ol>

                &lt!-- Wrapper for slides -->
                &ltdiv class="carousel-inner">
                  &ltdiv class="item active">
                    &ltimg src="./images/carousel/IMG_0325.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0475.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0511.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0769.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_1760.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_1794.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_2196.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_2212.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_9666.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_9685.jpeg">
                  &lt/div>
                &lt/div>

                &lt!-- Left and right controls -->
                &lta class="left carousel-control" href="#myCarousel" data-slide="prev">
                  &ltspan class="glyphicon glyphicon-chevron-left">&lt/span>
                  &ltspan class="sr-only">Previous&lt/span>
                &lt/a>
                &lta class="right carousel-control" href="#myCarousel" data-slide="next">
                  &ltspan class="glyphicon glyphicon-chevron-right">&lt/span>
                  &ltspan class="sr-only">Next&lt/span>
                &lt/a>
              &lt/div>
            &lt/div>
          &lt/th>
          &ltth class="buttonsPadding">
            &lth4 class="carouselRightText">
              This site is your resource for hiking in and around the Portland area. Think of it as a curated list of my favorite hikes.
              &ltbr>&ltbr>
              Browse and explore some of the featured hikes. You'll find trail highlights and photos from my favorite viewpoints. You'll also find current weather information if you're planning to get out today!
              &ltbr>&ltbr>
              Now go out there and explore what our extraordinary Pacific Northwest has to offer.
            &lt/h4>
          &lt/th>
        &lt/tr>
      &lt/thread>
    &lt/table>

    &ltbr>
    &ltbr>
    &lt!-- Footer image borred from traveloregon.com -->
    &ltdiv id="footberBottomTreesHome">&lt/div>

    &ltscript src="home.js">&lt/script>
  &lt/body>

&lt/html>
           
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">"Portland Hiker's Guide" website</p>
          <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
          <img class="codeExampleIcon" src="./images/CSSIcon.jpeg">
          <img class="codeExampleIcon" src="./images/javascriptIcon.jpeg">
          <br><br>
          <span class="codeTableInnerText">This is a website designed to inspire Portland area hikers to check out some of my favorite spots, broken into three types: Waterfalls, Dog-Friendly and Short Hikes.<br><br>
            I built this webpage from scratch, designing the layout and creating the content. I coded all HTML, CSS and Javascript. There is also a version built using Node.js and some of the Node modules, however those are hosted on a private network, unavailable to the public.</span><br><br>
            <span class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/">Live Website</a></span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/Web%20Design/PortlandHikersGuide">Full Code</a></p>
        </td>
      </tr>
    </table>
    </div>

    <br>

    <!--- Minesweeper Game -->
    <div class="codeExamplesClassReveal" id="minesweeperReveal">
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh
//Minesweeper game

#include &ltiostream>
#include &ltstdlib.h>
#include &lttime.h>
#include &ltstdio.h>

using namespace std;

//global constants
int SIZE; //length of the board (SIZE x SIZE)
int MINES; //amount of mines in play
const int MAXSIDE = 25;
const int MAXMINES = 99;
int mmx = -1;
int mmy = -1;
bool mm = false;

//function declarations
void gameSetup(char masterBoard[][MAXSIDE], char playerBoard[][MAXSIDE]);
void placeMines(int mines[][2], char masterBoard[][MAXSIDE]);
bool checkPosition (int row, int col);
bool mineCheck (int row, int col, char board[][MAXSIDE]);
void makeMove(int &x, int &y);
void checkMoveBounds(int &x, int &y);
bool moveMine (int row, int col, char board[][MAXSIDE],
        char masterBoard[][MAXSIDE]);
void printBoard(char playerBoard[][MAXSIDE]);
int adjacentMineCheck(int row, int col, int mines[][2],
        char masterBoard[][MAXSIDE]);
void playGame();
bool MSutility(char playerBoard[][MAXSIDE], char masterBoard[][MAXSIDE],
        int mines[][2], int row, int col, int &movesLeft);
void getGameSize();
void printRules();


int main()
{
    cout &lt&lt endl &lt&lt endl &lt&lt "Welcome to Minesweeper!" &lt&lt endl;
    printRules();
    getGameSize(); //prompts user for size of board
    playGame();
    cout &lt&lt endl &lt&lt endl;
    return 0;
}

//*******************FUNCTIONS*******************

//initializes a new, empty board for player
//INPUT: masterBoard array and playerBoard array
//OUTPUT: nothing
void gameSetup(char masterBoard[][MAXSIDE], char playerBoard[][MAXSIDE])
{
    // Initiate the random number generator so that
    // the same configuration doesn't arises
    srand(time (NULL));
  
    // Initialize all cells to empty (will add mines later in seperate func)
    for (int i = 0; i &lt= SIZE; i++)
    {
        for (int j = 0; j &lt= SIZE; j++)
        {
            playerBoard[i][j] = masterBoard[i][j] = '-';
        }
    }
    return;
}


//Places mines randomly throughout board
//INPUT: mines array, masterBoard array
//OUTPUT: nothing
void placeMines(int mines[][2], char masterBoard[][MAXSIDE])
{
    bool mark[MAXSIDE*MAXSIDE];
    int temp = MAXSIDE*MAXSIDE;
    for (int a = 0; a &lt= temp; a++)
    {
        mark [a] = false;
    }
  
  
    // Continue until all random mines have been created.
    for (int i = 0; i &lt MINES; )
      {
        int random = rand() % (SIZE*SIZE);
        int x = random / SIZE;
        int y = random % SIZE;
  
        // Add the mine if no mine is placed at this
        // position on the board
        if (mark[random] == false)
        {
            // Row for the mine
            mines[i][0] = x;
            // Column for the mine
            mines[i][1] = y;
  
            // Place mine
            masterBoard[mines[i][0]][mines[i][1]] = '*';
            mark[random] = true;
            i++;
        }
    }
    return;
}


//Check if a cell is valid/available to play
//INPUT: row and column
//OUTPUT: True is valid position, else false
bool checkPosition(int row, int col)
{
    if ((row >= 0) && (row &lt SIZE) && (col >= 0) && (col &lt SIZE))
        return true;
    else
        return false;
}


//checks if position selected has a mine or not
//INPUT: row, column and board array
//OUTPUT: true if a mine is at that position, else false
bool mineCheck (int row, int col, char board[][MAXSIDE])
{
    if (board[row][col] == '*')
        return true;
    else
        return false;
}
  

//Input user's move
//INPUT: x and y positions
//OUTPUT: nothing
void makeMove(int &x, int &y)
{
    // Take the input move
    cout &lt&lt "Enter your move" &lt&lt endl;
    cout &lt&lt "Row: ";
    cin >> x;
    cout &lt&lt "Column: ";
    cin >> y;
    return;
}


void checkMoveBounds(int &x, int &y)
{
    if ((x &lt 0) || (x >= SIZE) || (y &lt 0) || (y >= SIZE))
    {
    cout &lt&lt "Invalid input, please try again." &lt&lt endl;
        makeMove(x, y);
        checkMoveBounds(x, y);
    }
    else
        return;
}


//Moves a mine to a different position
//guarentees player's first move will not result in a mine position
//INPUT: row, column and board array
//OUTPUT: nothing
bool moveMine (int row, int col, char board[][MAXSIDE],
    char masterBoard[][MAXSIDE])
{
    //iterate to first empty location, replace that with a mine
    //make player's location an empty position
    for (int i = 0; i &lt SIZE; i++)
    {
        for (int j = 0; j &lt SIZE; j++)
            {
                if (masterBoard[i][j] != '*')
                {
                    masterBoard[i][j] = '*';
                    masterBoard[row][col] = '-';
                    return true;
                }
            }
    }
    return false;
}


//Prints the current board
//INPUT: playerBoard array
//OUTPUT: displays board
void printBoard(char playerBoard[][MAXSIDE])
{
    int i, j;
  
    cout &lt&lt ("      ");
  
    for (i = 0; i &lt SIZE; i++) //print top column numbers
    {
        if (i >= 10)
            cout &lt&lt " " &lt&lt i &lt&lt ".";
        else
            cout &lt&lt "  " &lt&lt i &lt&lt ".";
    }
  
    cout &lt&lt endl;
  
    for (i = 0; i &lt SIZE; i++)
    {
        if (i >= 10)
        {
            cout &lt&lt "  " &lt&lt i &lt&lt "."; //print row number
      
            for (j = 0; j &lt SIZE; j++)
                cout &lt&lt "   " &lt&lt playerBoard[i][j]; //print out items in that row
            cout &lt&lt endl; //heading to next row, new line
        }
        else
        {
            cout &lt&lt "   " &lt&lt i &lt&lt "."; //print row number
      
            for (j = 0; j &lt SIZE; j++)
                cout &lt&lt "   " &lt&lt playerBoard[i][j]; //print out items in that row
            cout &lt&lt endl; //heading to next row, new line


        }
    }
    return;
}
  
  
//Counts the number of mines in the 8 adjacent cells to user's position
//INPUT: row, column, mines array, masterBoard array
//OUTPUT: count of mines near user's position
int adjacentMineCheck(int row, int col, int mines[][2],
                                char masterBoard[][MAXSIDE])
{
    int count = 0;
  
//if cell is not valid (ie - outside board bounds), ignore
//North neighbour
        if (checkPosition (row-1, col) == true)
        {
                if (mineCheck (row-1, col, masterBoard) == true)
                count++;
        }
  //South neighbour
        if (checkPosition (row+1, col) == true)
        {
                if (mineCheck (row+1, col, masterBoard) == true)
                count++;
        }


//East neighbour
        if (checkPosition (row, col+1) == true)
        {
            if (mineCheck (row, col+1, masterBoard) == true)
                count++;
        }
  
//West neighbour
        if (checkPosition (row, col-1) == true)
        {
                if (mineCheck (row, col-1, masterBoard) == true)
                count++;
        }
  
//NE neighbour
        if (checkPosition (row-1, col+1) == true)
        {
            if (mineCheck (row-1, col+1, masterBoard) == true)
                count++;
        }
  
//NW neighbour
        if (checkPosition (row-1, col-1) == true)
        {
              if (mineCheck (row-1, col-1, masterBoard) == true)
                count++;
        }
  
//SE neighbour
        if (checkPosition (row+1, col+1) == true)
        {
                if (mineCheck (row+1, col+1, masterBoard) == true)
                count++;
        }
  
//SW neighbour
        if (checkPosition (row+1, col-1) == true)
        {
            if (mineCheck (row+1, col-1, masterBoard) == true)
                count++;
        }
  
    return (count);
}


//Play the minesweeper game
//NOTE - if player's first pick ims a mine, the game will move the mine.
//INPUT: nothing
//OUTPUT: nothing
void playGame ()
{
    //initialize variables / arrays
    bool gameOver = false;
    char masterBoard[MAXSIDE][MAXSIDE]; //gamemaster's board
    char playerBoard[MAXSIDE][MAXSIDE]; //players board
    int movesLeft = ((SIZE * SIZE) - MINES); //size of board minus minus
    int x;
    int y;
    int currentMove = 0;
    int mines[MAXMINES][2]; // will store position for all mines.
  
    //setup the gamemaster and player boards (all empty positions)
    gameSetup(masterBoard, playerBoard);
  
    //place the mines randomly on gamemaster's board
    placeMines (mines, masterBoard);
    
    while (gameOver == false)
    {
        cout &lt&lt "Current board :" &lt&lt endl;
        printBoard (playerBoard); //shows player's board
        makeMove (x, y); //Prompts player to pick position for mine
        checkMoveBounds(x, y); //checks the player's input


        //if first move of game == mine position, move that mine
        //guarentee's player's first move will be available
        if (currentMove == 0)
        {
            if (mineCheck(x, y, masterBoard) == true)
            {
                mm = moveMine(x, y, playerBoard, masterBoard);
                mmx = x;
                mmy = y;
            }
        }
        currentMove ++;
      
        gameOver = MSutility(playerBoard, masterBoard, mines, x, y, movesLeft);
      
        if (movesLeft &lt 0)
            movesLeft = movesLeft * -1;
        
        if ((gameOver == false) && (movesLeft == 0)) //player won!
        {
            printBoard (playerBoard);
            cout &lt&lt endl &lt&lt "You won!" &lt&lt endl;
            cout &lt&lt "Thank you for playing!" &lt&lt endl;
            gameOver = true;
        }


        if ((gameOver == true) && (movesLeft != 0)) //player lost
        {
            if (masterBoard[x][y] == '*')
            {
                playerBoard[x][y]='*';
              
                for (int i=0; i&ltMINES; i++)
                    playerBoard[mines[i][0]][mines[i][1]]='*';
                    
                if (mm == true) //original position was swapped
                {
                    int mmPosition =
                    adjacentMineCheck(x, y, mines, masterBoard) + 1 + '0';
                    playerBoard[mmx][mmy] = mmPosition;
                    printBoard (playerBoard);
                }
                else
                    printBoard (playerBoard);
            }
            cout &lt&lt "You lost." &lt&lt endl;
            cout &lt&lt "Better luck next time!" &lt&lt endl;
            cout &lt&lt "Thank you for playing!" &lt&lt endl;
        }
        //else continue playing...
    }
    return;
}


//Utility function to play minesweeper game (compares player's board to
// masterBoard)
//***Recursively moves until mine enountered
//INPUT: playerBoard, masterBoard and mines arrays, row, column and movesLeft
//OUTPUT: True if player picks a mine position (ends game), else false
bool MSutility(char playerBoard[][MAXSIDE], char masterBoard[][MAXSIDE],
            int mines[][2], int row, int col, int &movesLeft)
{


    //if not empty position, return false
    //base case ends (later) recurisve calls
    if (playerBoard[row][col] != '-')
        return false;


    //if player (or later recursion) picked position with a mine, return true
    if (masterBoard[row][col] == '*')
    {
        return true;
    }
    
    //else find adjacent free cells
    else
    {
    // Calculate the number of adjacent mines and put it on the board
        int count = adjacentMineCheck(row, col, mines, masterBoard);
        movesLeft--;
  
        playerBoard[row][col] = count + '0';
  
        if (!count)
        {
//if cell is not valid (ie - outside board bounds), ignore
//N neighbour
            if (checkPosition (row-1, col) == true)
            {
                    if (mineCheck (row-1, col, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col, movesLeft);
            }
  
//S neighbour
            if (checkPosition (row+1, col) == true)
            {
                    if (mineCheck (row+1, col, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col, movesLeft);
            }
  
//E neighbour
            if (checkPosition (row, col+1) == true)
            {
                if (mineCheck (row, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row, col+1, movesLeft);
            }
  
//W neighbour
            if (checkPosition (row, col-1) == true)
            {
                    if (mineCheck (row, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row, col-1, movesLeft);
            }
  
//NE neighbour
            if (checkPosition (row-1, col+1) == true)
            {
                if (mineCheck (row-1, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col+1, movesLeft);
            }
  
//NW neighbour
            if (checkPosition (row-1, col-1) == true)
            {
                  if (mineCheck (row-1, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col-1, movesLeft);
            }
  
//SE neighbour
            if (checkPosition (row+1, col+1) == true)
            {
                  if (mineCheck (row+1, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col+1, movesLeft);
            }
  
//SW neighbour
            if (checkPosition (row+1, col-1) == true)
            {
                if (mineCheck (row+1, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col-1, movesLeft);
            }
        }
        return false;
    }
}


//Prompts user for the size of the gameboard
//Note - # of mines in game is the same as one side of the board
// ie - 9x9 board = 9 mines. 20x20 board = 20 mines
//INPUT: nothing
//OUTPUT: nothing (changes global variables SIZE and MINES)
void getGameSize ()
{
    //user input must be >= 2 and &lt 25
    while ((SIZE &lt= 2) || (SIZE > 25))
    {
        cout &lt&lt "Enter the size of the game you would like to play ";
        cout &lt&lt "(min = 3, max = 25)." &lt&lt endl;
        cout &lt&lt "(example: 9 = 9x9 board)" &lt&lt endl;
        cout &lt&lt "size: ";
        cin >> SIZE;
        MINES = SIZE;
        if ((SIZE &lt= 2) || (SIZE > 25))
            cout &lt&lt "Invalid input, please try again." &lt&lt endl &lt&lt endl;
    }
    return;
}


//Prints out the rules of the game
//INPUT: nothing
//OUTPUT: nothing
void printRules()
{
    cout &lt&lt "RULES OF MINESWEEPER:" &lt&lt endl;
    cout &lt&lt "1. Don't pick a mine, or your game will be over!" &lt&lt endl;
    cout &lt&lt "2. If you pick a spot that is not a mine, you'll get a number. ";
    cout &lt&lt "That number will tell you how many adjacent cells have mines. "
            "Use that number (and maybe some luck) to guess where more open "
            "cells will be." &lt&lt endl;
    cout &lt&lt "3. If you open a cell with 0 neighboring mines, all the "
            "neighbors will automatically open." &lt&lt endl;
    cout &lt&lt "4. You win once all the cells without mines are found!" &lt&lt endl;


    
    cout &lt&lt endl;
    return;
}
                       
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Minesweeper game</p>
          <img class="codeExampleIcon" src="./images/c++Icon.jpeg">
          <br><br>
          <span class="codeTableInnerText">This is a simple buildout of a minesweeper game that runs through console. It is built using C++. <br><br>
            This was designed to implement different types of algorithms as well as an example of recursion. <br><br>
            This is the full code, so if you would like to play it, feel free to copy and paste in your own compiler.
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/C%2B%2B/Minesweeper%20Game">Full Code</a></p>
        </td>
      </tr>
    </table>
  </div>

    <br>

    <!-- Small Shell -->
    <div class="codeExamplesClassReveal" id="smallShellReveal">
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh

//create using:
    // gcc --std=gnu99 -o smallsh main.c
//then run using:
    // ./smallsh

#include &ltsys/wait.h>
#include &ltsys/types.h>
#include &ltsys/stat.h>
#include &ltunistd.h>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltfcntl.h>
#include &ltstring.h>
#include &ltsignal.h>
#include &ltstdbool.h>

//global variables
char* inputFile = NULL; //input file's name
char* outputFile = NULL; //output files's name
int status; //placeholder for exit status
int foregroundModeFlag = 0; //Flag for foreground only mode
int backgroundCounter = 0; //counter to keep track of background processes

// Signal actions
struct sigaction SIGINT_action = {0};
struct sigaction SIGTSTP_action = {0};

//function declarations
void runningLoop(char* homeDir);
void checkForProcesses(int* backgroundPIDs);
char* getInputLine();
char** parseInputLine(char *userInput, int* inputFlag, int* outputFlag, int* inputFileFlag, int* backgroundFlag);
void runCommands(char** parsed, int* inputFlag, int* outputFlag, char* homeDir, int* inputFileFlag, bool* continueRunning, int* backgroundFlag, int* backgroundPIDs);
void replaceWithPID(char *source, const char *searchFor, const char *replaceWith);
void addBgPID(int pidno, int* backgroundPIDs);
void removeBgPID(int pidno, int* backgroundPIDs);
void foregroundOnlyMode(int signo);
void freeMemPointer(char* file);
void freeMem2xPointer(char** file);


/*Main program will prompt user for a command. It will then parse the line
that the user entered into different tokens, store those in a seperate char
array, then execute those commands based on what is asked for. If a command
ends with "&" it will be sent to the background processes.
*/
int main (int argc, char* argv[]) 
{
  // get the home directory (from this program's environment variables)
    char* homeDir = getenv("HOME");
  
  //Initialize SITGINT
  SIGINT_action.sa_handler = SIG_IGN;
  sigaction(SIGINT, &SIGINT_action, NULL);


  //Initialize SIGTSTP (foreground-only)
  SIGTSTP_action.sa_handler = foregroundOnlyMode;
  sigfillset(&SIGTSTP_action.sa_mask);
  SIGTSTP_action.sa_flags = SA_RESTART;
  sigaction(SIGTSTP, &SIGTSTP_action, NULL);
  
  //Get input from user, do work, loop around until user enters "exit"
  //(this is the main workhorse of the program)
  runningLoop(homeDir);


  return 0;
}


/**************************************************************************
    FUNCTIONS
**************************************************************************/


//Main looping function - gets input from the user, parses that, checks for 
//running background processes, then executes commands. Loops until user
//enters "exit" command 
//INPUT: nothing 
//OUTPUT: nothing
void runningLoop(char* homeDir) 
{
  int inputFlag = 0; //flag if input file name is received (1 if true)
  int outputFlag = 0; //flag if output file name is received (1 if true)
  int inputFileFlag = 0; //flag if an input file is given (1 if true)
  bool continueRunning = true; //loop bool to continue running 
  char *userInput = NULL; //line to hold user's input
  char **parsed = NULL; //array to hold user's input parsed into seperate commands
  int backgroundFlag = 0; //background processes flag (1 if background process)
  int backgroundPIDs[100]; //storage array for background PID numbers

  while(continueRunning == true) 
  {
    int stdin_save = dup(STDIN_FILENO); // save stdin position
      int stdout_save = dup(STDOUT_FILENO); // save stdout position


    // Check background processes
    if (backgroundCounter > 0) 
    {	
      checkForProcesses(backgroundPIDs);
    }
    
    // Handle input
    userInput = getInputLine();
    parsed = parseInputLine(userInput, &inputFlag, &outputFlag, &inputFileFlag, &backgroundFlag);
    runCommands(parsed, &inputFlag, &outputFlag, homeDir, &inputFileFlag, &continueRunning, &backgroundFlag, backgroundPIDs);
    
    
    //free memory stored from last command line input
    freeMemPointer(userInput); //also frees inputFile if made
    freeMem2xPointer(parsed);


        //reset input and output file names and flags
    inputFile = NULL;
    outputFile = NULL;
    userInput = NULL;
    parsed = NULL;
      outputFlag = 0;
      inputFlag = 0;
      inputFileFlag = 0;
      
      dup2(stdout_save, STDOUT_FILENO); // restore standard out
        dup2(stdin_save, STDIN_FILENO); // restore standard in 
  }
}


//Function to check if there are any background processes that have 
//finished running. If so, print that they have finished
//INPUT: nothing
//OUTPUT: nothing
void checkForProcesses(int* backgroundPIDs) 
{
  // Check to see if a background process terminated
  pid_t bgPIDrunning;
  //see if any background processes are finished (if true, bgPIDrunning > 0)
  bgPIDrunning = waitpid(-1, &status, WNOHANG); 
  
  while (bgPIDrunning > 0) //if > 0, there is a background process done running
  {
    // If so, remove it from the array
    removeBgPID(bgPIDrunning, &*backgroundPIDs);
    
    // if it exited normally, print status
    if (WIFEXITED(status)) 
    {
      printf("background pid %d is done. exit value %d\n", bgPIDrunning, WEXITSTATUS(status)); 
      fflush(stdout);
    } 
    else if (WIFSIGNALED(status)) //if exited by signal, print signal 
    {
      printf("background pid %d is done. terminated by signal %d\n", bgPIDrunning, WTERMSIG(status)); 
      fflush(stdout);	
    }
    
    // Recheck background processes finished. If more, loop
    bgPIDrunning = waitpid(-1, &status, WNOHANG);
  }	
}


/*Prompt and get a command line from the user. 
Check if that line has "$$" in it. 
If it does, repalce it with the PID number currently being run */
//INPUT: nothing
//OUTPUT: string for the line of commands from user
char* getInputLine() 
{
  // Prompt the user for a new line of commands
  printf(": ");
  fflush(stdout);
  
  // Save the user's input into a char pointer "userInput"
  char *userInput = NULL;
  size_t bufsize = 0;
  getline(&userInput, &bufsize, stdin);
  
  //check if we need to replace any "$$" with PID number
  char *pidCheck = strstr(userInput, "$$");
  if (pidCheck != NULL) 
  {
    char alteredString[50];
    sprintf(alteredString, "%d", getpid());
    replaceWithPID(userInput, "$$", alteredString);
  }
  return userInput;
}


//Iterates through user's input line of commands, parses those commands into 
//seperate char pointers, stores in parsed array for later use (with exec...)
//INPUT char* userInput 
//OUTPUT parsed array
char** parseInputLine(char *userInput, int* inputFlag, int* outputFlag, int* inputFileFlag, int* backgroundFlag) 
{
  //allocate memory for parsed array
  char **parsed = malloc(100 * sizeof(char*)); 
  
  char *token; 
  char *prevToken = NULL;
  int position = 0;
  char* delim = " \t\r\n\a"; //used to seperate tokens
  
  // seperate userInput string into tokens
  token = strtok(userInput, delim);
    
  while (token != NULL) {
    
    // Output redirection
    if (strcmp(token, ">") == 0) {
      *outputFlag = 1;
      
      int input_fd = open(parsed[position-1], O_RDONLY);
      if (input_fd != -1) //error, assume there's a file it found 
      {
          *inputFileFlag = 1;
          inputFile = prevToken;
      }
      
      outputFile = strtok(NULL, delim);
      
      token = strtok(NULL, delim);
      parsed[position] = NULL;
      position++;
      continue;
    }
    
    // Input redirection
    if (strcmp(token, "&lt") == 0) {
      *inputFlag = 1;
      
      inputFile = strtok(NULL, delim);
      token = strtok(NULL, delim);
      parsed[position] = NULL;
      position++;
      continue;
    }
    
    // Background process
    if (strcmp(token, "&") == 0) {
      parsed[position] = NULL;
      if (foregroundModeFlag) 
      {
        *backgroundFlag = 0;
      } else 
      {
        *backgroundFlag = 1;
      }
      break;
    }			
    
    // Add to arguments
    parsed[position] = token; 
    position++;
    prevToken = token;
    token = strtok(NULL, delim);
  }
  
  // Set last argument to NULL
  parsed[position] = NULL;
  return parsed;
}


//Executes commands (first checks for built in commands, if not matching,
//send to launch to execute shell commands)
//INPUT: char **parsed, int* inputFlag, int* outputFlag, char* homeDir
//OUTPUT: nothing
void runCommands(char** parsed, int* inputFlag, int* outputFlag, char* homeDir, int* inputFileFlag, bool* continueRunning, int* backgroundFlag, int* backgroundPIDs)
{
    //variables to save PID numbers
    pid_t spawnPid;
  pid_t waitPid;
  
    //If it's a blank line or comment
  if (parsed[0] == NULL) //if blank line, don't do anything
  {
      return;
  } 
  else if (strcmp(parsed[0], "#") == 0) //if line starts with #, don't do anything (comment line)
  {
      return;
  }
  else if (strcmp(parsed[0], "exit") == 0) //check for exit command
  {
    while (backgroundCounter > 0) 
    {
      kill(backgroundPIDs[0],SIGTERM); //kill background process (if true) (using SIGTERM)
      removeBgPID(backgroundPIDs[0], backgroundPIDs); //remove background process kill from count / array
    }
    *continueRunning = false; //switch to false to exit runningLoop() and return to main
    
  } 
  else if (strcmp(parsed[0], "cd") == 0) //check for change directory command
  {
    //if no directory listed, change to home directory (homeDir)
    if (parsed[1] == NULL) 
    {
      if(chdir(homeDir) != 0) 
      {
        perror("chdir error"); //if error, print
        fflush(stdout);
      }
    } 
    else //change to directory listed by user 
    {
      if(chdir(parsed[1]) != 0) //if user directory not found...
      {
        perror("chdir error");//...print error
        fflush(stdout);
      }
    }	
  } 
  else if (strcmp(parsed[0], "status") == 0) //if status call, show last exit status
  {	
    if (WIFEXITED(status)) //check if last exited normally
    {
      printf("exit value %d\n", WEXITSTATUS(status));
      fflush(stdout);
    } 
    else if (WIFSIGNALED(status)) //else, check if exited by terminating signal
    {
      printf("terminated by signal %d\n", WTERMSIG(status));
      fflush(stdout);	
    }
  } 
  else //run exec... depending on what command is given
  {
      spawnPid = fork(); //fork child
      
      switch(spawnPid)
      {
          case -1: //fork didn't work, exit
          {
            perror("fork");
            fflush(stdout);
            exit(1);
          }
          case 0: //fork worked, child process running this
          {
            fflush(stdout);
        
            // Set input if specified
            if (*inputFlag) //if there is an input file, open and read it
            {
              int fd0 = open(inputFile, O_RDONLY); //open input file read only
              if (fd0 == -1) //if error opening input file, display error
              {
                printf("cannot open %s for input\n", inputFile);
                fflush(stdout);
                exit(1);
              } 
              else 
              {
                if (dup2(fd0, STDIN_FILENO) == -1)  //redirect stdin to input file descriptor
                {
                  perror("dup2");
                  fflush(stdout);
                }
                close(fd0);	
              }
            }
        
            if (*outputFlag) //if redirecting to output file
            {
                //open output file, create if new, append if already there. Read / write permissions
                int fd1 = open(outputFile, O_WRONLY | O_CREAT | O_APPEND, 0600);
              if (fd1 == -1) //if error creating output file, display error
              {
                printf("cannot create %s for output\n", outputFile);
                fflush(stdout);
                exit(1);			
              } 
              else //
              {
                if (dup2(fd1, STDOUT_FILENO) == -1) //redirect stout to output file descriptor
                {
                  perror("dup2");
                  fflush(stdout);
                }
                close(fd1);	
              }
            }
            
            
            if (*backgroundFlag) // if working in background
            {
                //set input and output to /dev/null for input/output in background
              if (!*inputFlag) //if no input file specified
              {
                int bgFDinput = open("/dev/null", O_RDONLY); //open read only
                if (bgFDinput == -1) {
                  printf("cannot open for input\n");
                  fflush(stdout);
                  exit(1);
                } 
                else 
                {
                  if (dup2(bgFDinput, STDIN_FILENO) == -1) 
                  {
                    perror("dup2");
                  }
                  close(bgFDinput); //close file	
                }	
              }
              
              // Set output to dev/null if not specified
              if (!*outputFlag) 
              {
                int bgFDoutput = creat("/dev/null", 0600); //create for ready/write
                if (bgFDoutput == -1) 
                {
                  printf("cannot set output\n");
                  fflush(stdout);
                  exit(1);			
                } 
                else 
                {
                  if (dup2(bgFDoutput, STDOUT_FILENO) == -1) 
                  {
                    perror("dup2");
                    fflush(stdout);
                  }
                  close(bgFDoutput);	
                }
              }	
            }
    
            // set SIGINT to foreground
            if (!*backgroundFlag) 
            {
              SIGINT_action.sa_handler = SIG_DFL;
              SIGINT_action.sa_flags = 0;
              sigaction(SIGINT, &SIGINT_action, NULL);
            }
            
            //execute commands (first check if using file for redirection)
            if (*inputFileFlag == 1) //if an input file is found (using redirect with file)
            {
                if(execlp("cat", outputFile, inputFile, NULL) == -1)
                    {
                        perror("Error executing command.");
                        fflush(stdout);
                    }
                    *inputFileFlag = 0; //reset inputFileFlag to 0
            }
            
            // execute all other commands
            else if (execvp(parsed[0], parsed)) 
            {
              perror(parsed[0]);
              fflush(stdout);
              exit(1);		
            }
          
          } 
          
          default: //parent process
          {
            if (!*backgroundFlag) //if not in background
            {
              do 
              {
                  //wait for any foreground processes to finish running (child process)
                waitPid = waitpid(spawnPid, &status, WUNTRACED); 
        
                if (waitPid == -1) //if error waiting, display error
                { 
                  perror("waitpid"); 
                  fflush(stdout);
                  exit(1); 
                }
                
                if (WIFSIGNALED(status)) //if process terminated by signal, display results
                {
                  printf("terminated by signal %d\n", WTERMSIG(status));
                  fflush(stdout);
                }
                
                if (WIFSTOPPED(status))  //if stopped by signal, display results
                {
                  printf("stopped by signal %d\n", WSTOPSIG(status));
                  fflush(stdout);
                }
        
              } 
              while (!WIFEXITED(status) && !WIFSIGNALED(status)); //while still running processes
          
            } 
            else //background mode on
            {
              printf("background pid is %d\n", spawnPid); //display background PID #
              fflush(stdout); 
              addBgPID(spawnPid, backgroundPIDs); //add background PID to array storing running bg processes
              *backgroundFlag = 0; // reset to point to foreground
            }
          }
      }
  }
    return;
}


//Replaces "$$" with pid in the source string 
//parts borrowed from stackoverflow.com
//INPUT: char *source, const char *searchFor, const char *replaceWith
//OUTPUT: nothing
void replaceWithPID(char *source, const char *searchFor, const char *replaceWith) 
{
  char buffer[2048] = {0}; //holding buffer
    char *insertPos = &buffer[0]; //starting insert point into buffer
    const char *tempArray = source; //temp char pointer
    size_t lenSearchFor = strlen(searchFor); //for this program, this is "$$"
    size_t lenReplaceWith = strlen(replaceWith); //PID # to replace "$$"
  
    while (1) //loop until it finds the item to replace (repeat until no more $$)
    {
    // See if our array has any "$$" in it
        const char *result = strstr(tempArray, searchFor);
        
    // No more "$$" found, copy over and exit function 
        if (result == NULL) 
        {
            strcpy(insertPos, tempArray); //copy our new string over the original
            break;
        }


        // Copy first part of string into a holding spot
        memcpy(insertPos, tempArray, result - tempArray);
        insertPos += result - tempArray;


        // Copy the PID into the "$$" position
        memcpy(insertPos, replaceWith, lenReplaceWith);
        insertPos += lenReplaceWith;


        // move the pointer up (new result + size of the PID we repalced "$$" with)
        tempArray = result + lenSearchFor;
    }


    // Copy the new string (buffer) back over the original string
    strcpy(source, buffer);
}


  //If background process called, add it's process number to the bg array tracker
  //INPUT: int pidno
  //OUTPUT: nothing
void addBgPID(int pidno, int* backgroundPIDs) 
{
  
    backgroundPIDs[backgroundCounter] = pidno;
  backgroundCounter++;	
}


//If a background process completes / exits, remove it from our background 
//array tracker
//INPUT: int pidno
//OUTPUT: nothing
void removeBgPID(int pidno, int* backgroundPIDs) 
{
    //loop through background array (backgroundPIDs[]) until it finds the pid number
    //that is needing to be removed
    for (int i = 0; i &lt backgroundCounter; i++) 
    {
    if (backgroundPIDs[i] == pidno) //pid number found, remove it
    {
      while (i &lt backgroundCounter - 1) //move array items over one position
      {
        backgroundPIDs[i] = backgroundPIDs[i + 1];
        i++;
      }
      backgroundCounter--; //remove 1 from background processes counter
      break;
    }
    }
    return;
}


//Enters or exits foreground-only mode depending on SIGTSTP
//INPUT: int signo 
//OUTPUT: nothing
void foregroundOnlyMode(int signo) 
{
  //enter the foreground-only mode
  if (foregroundModeFlag == 0) 
  {	
    char *message = "\nEntering foreground-only mode (& is now ignored)\n";
    write(STDOUT_FILENO, message, 50);
    foregroundModeFlag = 1;
  } 
  else //exit the foreground-only mode
  {
    char *message = "\nExiting foreground-only mode\n";
    write(STDOUT_FILENO, message, 30);
    foregroundModeFlag = 0; 
  }
  
  //writes prompt to the console
  char *prompt = ": "; 
  write(STDOUT_FILENO, prompt, 2); 
  fflush(stdout);
}


//free memory from a single char pointer 
//INPUT: char* file
//OUTPUT: nothing
void freeMemPointer(char* file)
{
    if (file != NULL)
    {
        free(file);
        file = NULL;
    }
    return;
}


//free memory from a double pointer char
//INPUT: char** file
//OUTPUT: nothing
void freeMem2xPointer(char**file)
{
    if (file != NULL)
    {
        free(file);
    }
    file = NULL;
    return;
}            
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Small shell</p>
          <img class="codeExampleIcon" src="./images/cIcon.jpg">
          <br><br>
          <span class="codeTableInnerText">This program will create a small shell for the user to enter commands on, similar to a bash shell. It is built using C. <br><br>
            Most commands will be executed by exec() type functions, except for "cd", "status", and "exit", along with expanding every instance of "$$" to the current working PID number. <br><br>
            Other commands include sending input/commands to a background process, output and input redirection, signal processing, and  other command variations, which can be found on the full GitHub repository.
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/C/Small%20Shell">Full Code</a></p>
        </td>
      </tr>
    </table>
  </div>
    
    <br>

    <!-- ASM calculating composites-->
    <div class="codeExamplesClassReveal" id="ASMReveal">
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
TITLE Composites     (Project4.asm)
; Author: Patrick Stumbaugh

; Description: Calculate composite numbers using procedures and loops

INCLUDE Irvine32.inc

HLIMIT = +400
LLIMIT = +1

.data
EC1		BYTE "**EC1: Align the output columns.",0
EC2		BYTE "**EC2: Display more composites",0
greet	BYTE "Composite Numbers programmed by Pat Stumbaugh",0
intro	BYTE "Enter the number of composite numbers you would like to see.",0
intro2	BYTE "I'll accept orders for up to 400 composites.", 0
ask		BYTE "Enter the number of composites to display [1 .. 400]: ",0
error	BYTE "Out of range. Try again.",0
goodbye	BYTE "Results certified by Pat Stumbaugh. Goodbye.",0
extra	BYTE "Would you like to see another ten composite numbers?",0
entry	BYTE "Type 1 for yes, 0 for no: ",0
spaces	BYTE "    ",0
space	BYTE " ",0
user	DWORD ?
checkN	DWORD 0 ;0 will indicate true, 1 will indicate false (for user check)
number	DWORD 4 ;starting at the first composite positive number
ten		DWORD 10
divisor	DWORD 1

.code
main PROC

;displays intro and greeting
  call	introduction

;displays extra credit
  mov		edx, OFFSET EC1
  call	WriteString
  call	CrLf
  mov		edx, OFFSET EC2
  call	WriteString
  call	CrLf
  call	CrLf

;gets user data / checks to see if it's in range
;(tried using stack for this call)
  push	OFFSET checkN
  push	OFFSET user
  call	getUserData

;displays user amount of composite numbers
  call	showComposites

;asks if user wants to see more composites
  call	ExtraCredit2

;displays goodbye message
  call	farewell

  exit	; exit to operating system
main ENDP


;-----------------------PROCEDURES-----------------------------


;displays the intro and greeting statement
;receive: nothing
;registers changed: edx, ebp
introduction PROC
  push	ebp
  mov		ebp, esp


  mov		edx, OFFSET greet
  call	WriteString
  call	CrLf
  call	CrLf


  mov		edx, OFFSET intro
  call	WriteString
  call	CrLf
  mov		edx, OFFSET intro2
  call	WriteString
  call	CrLf
  call	CrLf


  pop		ebp
  ret
introduction ENDP


;----------------------------------------------------------------------------
;prompts and gets user's number (stores in "user" variable)
;receives: offset user (user's number address), offset checkN
;registers changed: eax, ebx, edx, ebp
getUserData PROC
  push	ebp
  mov		ebp, esp


getUserNum:
  ;dispaly call message
  mov		eax, [ebp+12]			;checkN
  mov		ebx, 0					;reset checkN to 0
  mov		[eax], ebx
  mov		edx, OFFSET ask
  call	WriteString


  ;read the integer from the user, store in ebx
  mov		ebx, [ebp+8]			;user
  call	ReadInt
  mov		[ebx],eax


  ;push the user number and the checkN, call checkRange
  push	[ebp+12]				;checkN
  push	[ebp+8]					;user
  call	validate				;call sub-procedure


  ;see if checkN variable is still 0 (indicating user number
  ;is within range. If true, continue on, if false, start over from top
  mov		ebx, [ebp+12]
  mov		eax, [ebx]
  mov		ebx, 0
  cmp		eax, ebx
  jnz		getUserNum


  pop		ebp
  ret		8
getUserData ENDP


;----------------------------------------------------------------------------
;checks the user's number to our specified range
;receives: offset user, offset checkN
;registers affected: eax, ebx, ebp
validate PROC
  push	ebp
  mov		ebp, esp


  ;check upper limit
  mov		eax, [ebp+8]			;move address of user into eax
  mov		eax, [eax]				;move value of user into eax
  mov		ebx, HLIMIT		
  cmp		eax, ebx
  jg		outOfRange				;jump to error if greater than upper limit


  ;check lower limit
  mov		eax, [ebp+8]			;move address of user into eax
  mov		eax, [eax]				;move value of user into eax
  mov		ebx, LLIMIT		
  cmp		eax, ebx
  jge		continue				;jump to continue if above lower limit


  ;display out of range message, change checkN to 1 (indicating false)
  ;I'm using 1 as a fault and 0 as a true message in the main
outOfRange:
  mov		edx, OFFSET error
  call	WriteString
  call	CrLf
  mov		eax, [ebp+12]
  mov		ebx, 1
  mov		[eax], ebx


continue:
  pop		ebp
  ret		8
validate ENDP


;----------------------------------------------------------------------------
;displays all the composite numbers up through the user's number
;makes a new line every ten numbers displayed
;received: nothing
;registers affected: ebx, ecx, ebp
showComposites PROC
  push	ebp
  mov		ebp, esp
  call	CrLf


  mov		ten, 10					;numbers per line counter
  mov		ecx, user				;user number used for loop


L1:
  pushad							;save registers to stack
  call isComposite				;call sub-procedure
  popad							;bring back registers from stack


;subtracts 1 from our ten counter. If 0, make a new line, if not, loop back
  sub		ten, 1
  mov		ebx, ten
  cmp		ebx, 0
  jz		resetTen
  loop	L1						;**uses LOOP to decrement ecx


;resets the line counter back to ten
;if the loop counter (ecx) is at 0, then jump to finish
resetTen:
  mov		ten, 10
  call	CrLf
  mov		ebx, ecx
  cmp		ebx, 0
  jz		continue
  loop	L1						;**uses LOOP to decrement ecx


continue:
  pop		ebp
  ret		
showComposites ENDP

;----------------------------------------------------------------------------
;finds the next composite number, displays it
;receives: nothing
;registers affected: eax, ebx, edx, ebp
isComposite PROC
  push	ebp
  mov		ebp, esp


;sets up starting variables
  mov		eax, number				;number will be last number tried
  mov		divisor, 1				;sets our starting divisor to 1
  mov		ebx, 0					;used to count number of divisions
  jmp		L1


;resets divisor, ebx counter and increments number
reset:
  inc		number
  mov		eax, number
  mov		divisor, 1
  mov		ebx, 0


;compares our current number to the divisor
L1:
  mov		edx, 0
  mov		eax, number
  cdq
  idiv	divisor
;if no remainder (found a clean division), jump to foundDivision
;otherwise increment divisor and try again
;if divisor is equal to the number, jump to reset loop
  cmp		edx, 0
  jz		foundDivision
  inc		divisor
  mov		eax, number
  cmp		eax, divisor
  je		reset
  jmp		L1


foundDivision:
  inc		ebx
  cmp		ebx, 2					;if divisable by 2+ #'s (it's composite)
  je		foundComposite
  inc		divisor
  mov		eax, number
  cmp		divisor, eax
  je		reset
  jmp		L1


;composite number found, display it, add one (for next time called) and return
foundComposite:
  mov		eax, number
  cmp		eax, 100
  jge		more1
  mov		edx, OFFSET space
  call	WriteString
more1:
  mov		eax, number
  cmp		eax, 10
  jge		more
  mov		edx, OFFSET space
  call	WriteString
more:
  mov		edx, OFFSET spaces
  call	WriteString
  mov		eax, number
  call	WriteDec
  inc		number
  jmp		continue


continue:
  pop		ebp
  ret		
isComposite ENDP


;----------------------------------------------------------------------------
;Displays goodbye message
;receives: nothing
;registers affected: edx, ebp
farewell PROC
  push	ebp
  mov		ebp, esp


  call	CrLf
  mov		edx, OFFSET goodbye
  call	WriteString
  call	CrLf


  pop		ebp
  ret
farewell ENDP


;----------------------------------------------------------------------------
;Displays another line of composites (extra credit 2)
;receives: nothing
;registers affected: ebp, edx
ExtraCredit2 PROC
  push	ebp
  mov		ebp, esp


;ask if user wants another ten numbers
L1:
  call	CrLf
  mov		edx, OFFSET extra
  call	WriteString
  call	CrLf
  mov		edx, OFFSET entry
  call	WriteString
  call	ReadInt
  cmp		eax, 1
  jne		continue


  mov		user, 10				;adds ten to our previous user number
  call showComposites				;displays another ten composites
  jmp L1


continue:
  pop		ebp
  ret
ExtraCredit2 ENDP

END main    
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Calculate Composite Numbers</p>
          <img class="codeExampleIcon" src="./images/asmIcon.png">
          <br><br>
          <span class="codeTableInnerText">This program will calculate and display all composite numbers up through a user inputted max number. It is built using Assembly Language. <br><br>
            The program is designed as a way to practice calling procedures and sub-procedures while pushing and popping variables to and from the stack memory. <br><br>
            It also is a practice in using different types of registers, including the instruction pointer while in a called procedure. It also has loops, jumps, compares and other methods. 
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/Assembly%20Language/Calculating%20Composites">Full Code</a></p>
        </td>
      </tr>
    </table>
  </div>

    <br>

    <!-- Map Reduce -->
    <div class="codeExamplesClassReveal" id="mapReveal">
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh
/*compile by using command: rustc main.rs 
Then, execute using command: ./main num_partitions num_elements
Where num_partitions and num_elements are your choice
(ie): ./main 6 153

use std::env; // to get arugments passed to the program
use std::thread; // for threads

//A single threaded map-reduce program
fn main() {

    // Use std::env to get arguments passed to the program
    let args: Vec&ltString> = env::args().collect();
    if args.len() != 3 {
        println!("ERROR: Usage {} num_partitions num_elements", args[0]);
        return;
    }
    //number of partitions to create:
    let num_partitions : usize = args[1].parse().unwrap();
    //number of elements total being used:
    let num_elements : usize = args[2].parse().unwrap();
    
    //if less than one partition, error:
    if num_partitions &lt 1{
      println!("ERROR: num_partitions must be at least 1");
        return;
    }
    
    //if there are more partitions then there are elements, error:
    if num_elements &lt num_partitions{
        println!("ERROR: num_elements cannot be smaller than num_partitions");
        return;
    }

    // Generate data to go in our partitions (saved as a vector)
    let v = generate_data(num_elements);

    // PARTITION STEP: partition the data into 2 partitions
    let xs = partition_data_in_two(&v);

    // Print info about the partitions
    print_partition_info(&xs);

    let mut intermediate_sums : Vec&ltusize> = Vec::new();

    //following code is an example of running two threads concurrently, 
    //manually coded to do so. 
    let xs_clone = xs.clone(); //using a clone for the first handle
    let part1 = thread::spawn(move ||map_data(&xs_clone[0]));
    let part2 = thread::spawn(move ||map_data(&xs[1]));
    
    //join/unwrap our threads
    let new1 = part1.join().unwrap();
    let new2 = part2.join().unwrap();
    
    //push our threads (already joined) to the intermediate_sums
    intermediate_sums.push(new1);
    intermediate_sums.push(new2);

    // Print the vector with the intermediate sums
    println!("Intermediate sums = {:?}", intermediate_sums);

    // REDUCE STEP: Process the intermediate result to produce the final result
    let sum = reduce_data(&intermediate_sums);
    println!("Sum = {}", sum);


    //following is an example of running an unknown amount of threads concurrently

    //variables:
    let mut intermediate_sums2 : Vec&ltusize> = Vec::new();//create a new vector to hold intermediate sums
    let mut part_counter = 0;//number of partitions we'll have to make individual threads for (used as a counter)
    let mut handles = Vec::new(); //create a new vector for handles (to hold our threads)
    
    //Calls partition_data to partition the data into equal partitions
    let partitioned_data = partition_data(num_partitions, &v);
    
    //Calls print_partition_info to print info on the partitions that have been created
    print_partition_info(&partitioned_data);

    //Creates one thread per partition and uses each thread to concurrently process one partition
    while part_counter != num_partitions {
        let part_clone = partitioned_data.clone(); //clone variable
        let new_part1 = thread::spawn(move ||map_data(&part_clone[part_counter])); //spawn a new thread
        handles.push(new_part1); //save new thread by pushing to handles vector
        part_counter = part_counter + 1;//increment counter
    }
    
    //Collects the intermediate sums from all the threads
    for child in handles {
        let adding_item = child.join().unwrap(); //join the return value for each item in handles vector of threads
        intermediate_sums2.push(adding_item); //push to the intermediate_sums2
    }
    
    //Prints information about the intermediate sums
    println!("Intermediate sums = {:?}", intermediate_sums2);


    //Calls reduce_data to process the intermediate sums
    let sum2 = reduce_data(&intermediate_sums2);
    
    //Prints the final sum computed by reduce_data
    println!("Sum = {}", sum2);
    
}

//*******FUNCTIONS**********

//Print the number of partitions and the size of each partition
fn print_partition_info(vs: &Vec&ltVec&ltusize>>){
    println!("Number of partitions = {}", vs.len());
    for i in 0..vs.len(){
        println!("\tsize of partition {} = {}", i, vs[i].len());
    }
}


//Create a vector with integers from 0 to num_elements -1
fn generate_data(num_elements: usize) -> Vec&ltusize>{
    let mut v : Vec&ltusize> = Vec::new();
    for i in 0..num_elements {
        v.push(i);
    }
    return v;
}


//Partition the data in the vector v into 2 vectors

fn partition_data_in_two(v: &Vec&ltusize>) -> Vec&ltVec&ltusize>>{
    let partition_size = v.len() / 2;
    // Create a vector that will contain vectors of integers
    let mut xs: Vec&ltVec&ltusize>> = Vec::new();


    // Create the first vector of integers
    let mut x1 : Vec&ltusize> = Vec::new();
    // Add the first half of the integers in the input vector to x1
    for i in 0..partition_size{
        x1.push(v[i]);
    }
    // Add x1 to the vector that will be returned by this function
    xs.push(x1);


    // Create the second vector of integers
    let mut x2 : Vec&ltusize> = Vec::new();
    // Add the second half of the integers in the input vector to x2
    for i in partition_size..v.len(){
        x2.push(v[i]);
    }
    // Add x2 to the vector that will be returned by this function
    xs.push(x2);
    // Return the result vector
    xs
}


//Sum up the all the integers in the given vector
fn map_data(v: &Vec&ltusize>) -> usize{
    let mut sum = 0;
    for i in v{
        sum += i;
    }
    sum
}


//Sum up the all the integers in the given vector
fn reduce_data(v: &Vec&ltusize>) -> usize{
    let mut sum = 0;
    for i in v{
        sum += i;
    }
    sum
}

/* Partitions the data into a number of partitions such that
* - the returned partitions contain all elements that are in the input vector
* - if num_elements is a multiple of num_partitions, then all partitions must have equal number of elements
* - if num_elements is not a multiple of num_partitions, some partitions can have one more element than other partitions
*/
fn partition_data(num_partitions: usize, v: &Vec&ltusize>) -> Vec&ltVec&ltusize>>{

    //size of each partition
    let part_size = v.len()/num_partitions;
    let mut leftovers = v.len()%num_partitions;


    //Vector of vectors of integers
    let mut array_vector: Vec&ltVec&ltusize>> = Vec::new(); //create vector holding an array of vectors of integers
    let mut counter = 0; //holding item for data in v
    let mut looper = 0; //holding item for looping through number of partitions
    
    while looper != num_partitions {
        //create a temp vector to hold items
        let mut adding_vector : Vec&ltusize> = Vec::new();
        
        //loop through the param data, adding to our temp vector
        for _i in 0..part_size {
            adding_vector.push(v[counter]);
            counter = counter + 1; //increment counter
        }
        
        //add any leftovers if given
        if leftovers != 0 {
            adding_vector.push(v[counter]);
            counter = counter + 1; //increment counter
            leftovers = leftovers - 1; //decrement leftovers
        }
        
        //push our temp vector to the main vector 
        array_vector.push(adding_vector);
        
        //increment the looper
        looper = looper + 1;
    }
    
    return array_vector;
}            
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Map Reduce</p>
          <img class="codeExampleIcon" src="./images/rustIcon.jpg">
          <br><br>
          <span class="codeTableInnerText">This program is an example of both a single-threaded and multi-threaded Rust program, with all threads running concurrently. <br><br>
            The program is split into two sections. The first section takes the data and splits it in two, then runs the algorithm and manually splits the results into two partitions, running each as a thread concurrently. <br><br>
            The second part of the program takes the same data, but splits it into the user specified number of partitions. Then, these partitions will create just as many threads, running concurrently. 
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/Rust/MapReduce">Full Code</a></p>
        </td>
      </tr>
    </table>
  </div>

    <br>

    <!-- Workout Table -->
    <div class="codeExamplesClassReveal" id="workoutReveal">
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
var express = require('express');
var mysql = require('./dbcon.js');

var app = express();
var handlebars = require('express-handlebars').create({
defaultLayout: 'main'
});

app.engine('handlebars', handlebars.engine);
app.set('view engine', 'handlebars');
app.set('port', 8129);

app.use(express.static('public'));

//home page setup
//Get and display (send back) all the items from the SQL table
app.get('/', function(req, res, next) {
var context = {};

mysql.pool.query('SELECT * FROM workouts', function(err, rows, fields) {
if (err) {
  next(err);
  return;
}
var qParams = [];
for (var p in rows.query) {
  qParams.push({
    'name': p,
    'reps': rows.query[p]
  })
}
context.dataList = rows;
res.render('home', context);
});
});

//home page setup
//Get and display (send back) all the items from the SQL table
app.post('/', function(req, res, next) {
var context = {};
mysql.pool.query('SELECT * FROM workouts', function(err, rows, fields) {
if (err) {
  next(err);
  return;
}
var qParams = [];
for (var p in rows.query) {
  qParams.push({
    'name': p,
    'reps': rows.query[p]
  })
}
context.dataList = rows;
res.render('home', context);
});
});

//Inserts a new row into the SQL table
app.get('/insert', function(req, res, next) {
var context = {};
mysql.pool.query("INSERT INTO workouts (`name`, `reps`, `weight`, `date`, `unit`) VALUES (?, ?, ?, ?, ?)", [req.query.name, req.query.reps, req.query.weight, req.query.date, req.query.unit], function(err, result) {
if (err) {
  next(err);
  return;
}
context.id = result.insertId;
context.name = req.query.name;
context.reps = req.query.reps;
context.weight = req.query.weight;
context.date = req.query.date;
context.unit = req.query.unit;
JSON.stringify(context);
res.send(context); //send this info back to the client calling it
//res.render('home', context);
});
});

//deletes a row from the SQL table using the ID number
app.get('/delete', function(req, res, next) {
var context = {};
mysql.pool.query("DELETE FROM workouts WHERE id=?", [req.query.id], function(err, result) {
if (err) {
  next(err);
  return;
}
context.results = "Deleted " + result.changedRows + " rows.";
res.render('home', context);
});
});

//updates a row from the SQL table using the ID number
app.get('/updateItem', function(req, res, next) {
var context = {};
mysql.pool.query('SELECT * FROM workouts WHERE id=?', [req.query.id], function(err, rows, fields) {
if (err) {
  next(err);
  return;
}
var qParams = [];
for (var p in rows.query) {
  qParams.push({
    'name': p,
    'reps': rows.query[p]
  })
}
context.dataList = rows;
res.render('update', context);
});
});

//Gets a certain row's details and sends back to client
//This is not used in this current assigment (I build it as a test)
app.get('/getItemDetail', function(req, res, next) {
var context = {};
mysql.pool.query('SELECT * FROM workouts WHERE id=?', [req.query.id], function(err, result) {
if (err) {
  next(err);
  return;
}
JSON.stringify(result);
res.send(result); //send this info back to the client calling it
});
});


//Updates a row based on the ID number
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safe-update', function(req, res, next) {
var context = {};
mysql.pool.query("SELECT * FROM workouts WHERE id=?", [req.query.id], function(err, result) {
if (err) {
  next(err);
  return;
}
if (result.length == 1) {
  var curVals = result[0];
  mysql.pool.query("UPDATE workouts SET name=?, reps=?, weight=?, date=?, unit=? WHERE id=? ",
    [req.query.name || curVals.name, req.query.reps || curVals.reps, req.query.weight || curVals.weight, req.query.date || curVals.date, req.query.unit || curVals.unit, req.query.id],
    function(err, result) {
      if (err) {
        next(err);
        return;
      }
      context.results = "Updated " + result.changedRows + " rows.";
      res.render('home', context);
    });
}
});
});

//resets a table to blank
app.get('/reset-table', function(req, res, next) {
var context = {};
mysql.pool.query("DROP TABLE IF EXISTS workouts", function(err) { //replace your connection pool with the your variable containing the connection pool
var createString = "CREATE TABLE workouts(" +
  "id INT PRIMARY KEY AUTO_INCREMENT," +
  "name VARCHAR(255) NOT NULL," +
  "reps INT," +
  "weight INT," +
  "date DATE," +
  "unit VARCHAR(255))";
mysql.pool.query(createString, function(err) {
  context.results = "Table reset";
  res.render('home', context);
})
});
});


app.use(function(req, res) {
res.status(404);
res.render('404');
});


app.use(function(err, req, res, next) {
console.error(err.stack);
res.status(500);
res.render('500');
});


app.listen(app.get('port'), function() {
console.log('Express started on flip3.engr.oregonstate.edu:' + app.get('port') + '; press Ctrl-C to terminate.');
});
                            
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Workout Table</p>
          <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
          <img class="codeExampleIcon" src="./images/CSSIcon.jpeg">
          <img class="codeExampleIcon" src="./images/javascriptIcon.jpeg">
          <img class="codeExampleIcon" src="./images/ajaxIcon.jpeg">
          <img class="codeExampleIcon" src="./images/nodejsIcon.png">
          <img class="codeExampleIcon" src="./images/handlebarsIcon.png">
          <img class="codeExampleIcon" src="./images/mysqlIcon.png">
          <br><br>
          <span class="codeTableInnerText">This is an example of a dynamic table to track your workouts, built it as an example of full stack development, linking the frontend with the backend.<br><br>
            Frontend development is using HTML5, CSS and Javascript. Backend development
            is using Node.js, Express, Handlebars, and MySQL. 
            The table also uses AJAX when updating, deleting or resetting the table, so that the user does not have to refresh the page every time a change is made.<br><br>
            The code seen here is the node.js code for the backend of the website.
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="https://github.com/pstumbaugh/Portfolio/tree/main/Web%20Design/Front%20and%20Backend%20Table">Full Code</a></p>
        </td>
      </tr>
    </table>
    </div>

    <br>
  </div>
  <!-- base coding template
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
Code here
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Portfolio website</p>
          <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
          <br><br>
          <span class="codeTableInnerText">text here
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="">Full Code</a></p>
        </td>
      </tr>
    </table>

    <br><br>
  -->


    <a target="_blank" href="https://github.com/pstumbaugh/Portfolio" id="githubPortfolioLink">GitHub Portfolio</a>


    <br>

    <br><br>

    <!-- footer links -->
    <div class="footerLinks">
      <a class="footerLink" href="tel:6508683189"><img class="footerIcon" src="./images/phoneIcon.png">
        <p class="footerText">(650) 868-3189</p>
      </a>
      <a class="footerLink" href="mailto:stumbaugh.patrick@gmail.com"><img class="footerIcon" src="./images/emailIcon.png">
        <p class="footerText">stumbaugh.patrick@gmail.com</p>
      </a>

      <br>
      <a target="_blank" href="https://github.com/pstumbaugh/Portfolio">
        <img class="buttonsImage" src="./images/githublogo2.png" alt="Github"></a>
      &nbsp;&nbsp;&nbsp;
      <a target="_blank" href="https://www.linkedin.com/in/patrick-stumbaugh-7625662a/">
        <img class="buttonsImage" src="./images/linkedinlogo2.png" alt="LinkedIn"></a>


        <!-- footer image-->
    <div class="drippingYellowContainerBottom">
      <img class="drippingYellowBottom" src="./images/upsideDownDrippingYellowEditedSIDES.png">
    </div>

    <div class="drippingYellowContainerCenter">
      <img class="drippingYellowCenter" src="./images/upsideDownDrippingYellowEditedSIDES.png">
    </div>
    <script src="home.js"></script>
  </body>

</html>

